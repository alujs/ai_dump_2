# .ai — MCP Controller

Policy-gated code execution controller backed by Neo4j.
Drop this folder into your Angular repo. VS Code Copilot (or any MCP client) gets a single tool — `controller_turn` — that enforces evidence-linked plans before any code changes.

---

## 1. Prerequisites

| What | Version | Install |
|------|---------|---------|
| Node.js | ≥ 25 | `brew install node` or [nvm](https://github.com/nvm-sh/nvm): `nvm install 25 && nvm use 25` |
| Neo4j | 5.x | `brew install neo4j` or [Neo4j Desktop](https://neo4j.com/download/) |
| VS Code | latest | With GitHub Copilot + Copilot Chat extensions |

---

## 2. Dependencies

Your Angular repo already has `@angular/compiler` and `typescript`. You just need to add the few extras the controller depends on:

```bash
npm install -D tsx ts-morph neo4j-driver
```

> `yaml` and `express` — add them too if your repo doesn't already have them:
> `npm install -D yaml express @types/express`

That's it. No separate install step, no `.ai/package.json`. Everything resolves from your repo's `node_modules/`.

---

## 3. Configure Neo4j

Start Neo4j and create a database called `piopex`.

**Default connection (works with local Neo4j out of the box):**

| Setting | Default |
|---------|---------|
| URI | `bolt://127.0.0.1:7687` |
| Username | `neo4j` |
| Password | `12345678` |
| Database | `piopex` |

**To override**, create `.ai/config/env.local.json` (gitignored):

```json
{
  "neo4j": {
    "uri": "bolt://your-host:7687",
    "username": "neo4j",
    "password": "your-password",
    "database": "piopex"
  }
}
```

Or set environment variables: `NEO4J_URI`, `NEO4J_USERNAME`, `NEO4J_PASSWORD`, `NEO4J_DATABASE`.

Verify the connection:

```bash
npm run ai:check
# → "graphops connectivity check passed."
```

---

## 4. Secrets & Tokens

### Jira Personal Access Token

Create the file `.ai/auth/jira.token` containing your PAT (one line, no newline):

```bash
echo -n "YOUR_JIRA_PAT_HERE" > .ai/auth/jira.token
```

Then set your Jira base URL in `.ai/config/env.local.json`:

```json
{
  "jira": {
    "baseUrl": "https://your-org.atlassian.net"
  }
}
```

The `.ai/auth/` directory is gitignored. Never commit tokens.

### Swagger / OpenAPI specs

If your project has Swagger roots, add them to `.ai/config/env.local.json`:

```json
{
  "swagger": {
    "roots": ["path/to/openapi.yaml"]
  }
}
```

---

## 5. Day-0 Setup (One Command)

After Neo4j is running and configured:

```bash
npm run ai:setup
```

That's it. This single command:
1. Scans your repo's TypeScript + HTML via ts-morph and @angular/compiler
2. Extracts symbols, routes, components, template usage, domain anchors
3. Writes JSONL files to `.ai/graph/seed/fact/`
4. Drops and rebuilds the Neo4j database from all seed data (policy + fact + recipe)

Verify:

```bash
npm run ai:check
# → "graphops connectivity check passed."
```

> **After code changes:** Run `npm run ai:seed-facts` to re-scan and re-sync.
> **After policy-only edits:** Run `npm run ai:sync` (skips the AST scan).

### Seed file layout

```
.ai/graph/seed/
├── fact/           # Auto-generated by ai:setup — DO NOT hand-edit
│   ├── anchors.jsonl      # DomainAnchor nodes + CONTAINS edges
│   ├── symbols.jsonl      # SymbolDefinition nodes
│   ├── components.jsonl   # Component + UsageExample nodes
│   ├── routes.jsonl       # AngularRoute nodes
│   └── edges.jsonl        # All cross-entity edges
├── policy/         # Hand-curated — edit these, then npm run ai:sync
│   ├── policies.jsonl
│   ├── migration_rules.jsonl
│   ├── intent_and_constraints.jsonl
│   └── lexeme_aliases.jsonl
└── recipe/         # Codemod/recipe definitions
    └── manifest.jsonl
```

---

## 6. What Gets Extracted

`ai:setup` scans your repo and produces the following graph entities:

| Entity | Source | Parser |
|--------|--------|--------|
| **DomainAnchors** | Folder structure (configurable depth) | `anchorSeeder.scanAnchors()` |
| **SymbolDefinitions** | Every `.ts`/`.js` file | `ts-morph` — classes, interfaces, functions, enums, types, variables |
| **Components + UsageExamples** | Every `.html` template | `@angular/compiler` — `adp-*`, `sdf-*`, custom element tags with attributes |
| **AngularRoutes** | Route config files (`.routes.ts`, `app.config.ts`, `app.module.ts`) | `ts-morph` — `Routes[]`, `provideRouter()`, `RouterModule.forRoot/forChild()` |
| **Template routerLinks** | Every `.html` template | `@angular/compiler` — `routerLink`, `[routerLink]` directive values |

**Graph edges:**

| Edge | From → To |
|------|-----------|
| `DECLARES` | File → SymbolDefinition |
| `IN_ANCHOR` | Symbol / Route / UsageExample → DomainAnchor |
| `HAS_USAGE` | Component → UsageExample |
| `ROUTES_TO` | AngularRoute → File (component target) |
| `LOADS_CHILDREN` | AngularRoute → File (child route file) |
| `CHILD_OF` | AngularRoute (child) → AngularRoute (parent) |
| `REFERENCES_ROUTE` | File (template) → AngularRoute (matched by routerLink path) |

**Runtime-only index (not in Neo4j):** On MCP server startup, `IndexingService.rebuild()` builds an in-memory index with line-precise symbol lookup and full-text search. The graph stores "index cards" + relationships; the runtime index stores the full AST detail.

### SDF / Waypoint components

If your repo has a Waypoint `components.d.ts`, the `sdfContractParser` can parse it into Component + Prop graph nodes. Available programmatically via `src/domains/indexing/sdfContractParser.ts` — CLI wrapper coming.

### Configuration

Scan targets: `.ai/config/base.json` → `ingestion.includes` / `ingestion.excludes` and `parserTargets`.

---

## 7. Connect to VS Code (MCP Setup)

Create `.vscode/mcp.json` in your repo root:

```jsonc
{
  "servers": {
    "mcp-controller": {
      "command": "node",
      "args": [
        "--import", "tsx",
        ".ai/mcp-controller/src/mcp/stdioServer.ts"
      ],
      "env": {
        "NEO4J_URI": "bolt://127.0.0.1:7687",
        "NEO4J_USERNAME": "neo4j",
        "NEO4J_PASSWORD": "12345678",
        "NEO4J_DATABASE": "piopex"
      }
    }
  }
}
```

> A template with all env vars is at `.ai/config/mcp.client.template.json`.

**Verify:**

1. Command Palette → **MCP: List Servers** → confirm `mcp-controller` appears
2. Command Palette → **MCP: Start Server** → start it
3. In Copilot Chat (agent mode), the `controller_turn` tool should appear

---

## 8. General Usage

### How a session works

```
initialize_work → read/search/escalate → submit_execution_plan → apply patches → signal_task_complete
```

Every interaction goes through `controller_turn` with a `verb` parameter:

| Phase | Verbs |
|-------|-------|
| **Bootstrap** | `initialize_work` — sends prompt, gets contextPack + strategy + planGraphSchema |
| **Explore** | `read_file_lines`, `lookup_symbol_definition`, `trace_symbol_graph`, `search_codebase_text` |
| **Expand context** | `escalate` — request additional files/symbols be added to the contextPack |
| **Plan** | `submit_execution_plan` — submit a PlanGraphDocument for validation |
| **Execute** | `apply_code_patch`, `run_sandboxed_code`, `execute_gated_side_effect` |
| **Finish** | `signal_task_complete` — triggers retrospective + memory candidates |

### Re-scanning the repo (after code changes)

```bash
npm run ai:seed-facts
```

### Resyncing the database (after hand-editing policy seed files)

```bash
npm run ai:sync
```

### Exporting current graph state

```bash
npm run ai:export
# Writes JSONL to .ai/graph/out/
```

### Adding human override memories

Drop a JSON file in `.ai/memory/overrides/`:

```json
{
  "domainAnchorIds": ["anchor:src/app"],
  "enforcementType": "plan_rule",
  "planRule": {
    "condition": "migration changes must include a test node",
    "denyCode": "PLAN_MISSING_TEST_VALIDATION",
    "requiredSteps": [{ "kind": "validate", "targetPattern": "spec" }]
  },
  "note": "Require test coverage for all migration changes"
}
```

The controller ingests these on next `initialize_work` and renames them to `.processed`.

---

## 9. Environment Variables Reference

| Variable | Default | Purpose |
|----------|---------|---------|
| `NEO4J_URI` | `bolt://127.0.0.1:7687` | Neo4j connection |
| `NEO4J_USERNAME` | `neo4j` | Neo4j auth |
| `NEO4J_PASSWORD` | `12345678` | Neo4j auth |
| `NEO4J_DATABASE` | `piopex` | Neo4j database name |
| `MCP_REPO_ROOT` | auto-detected | Root of the repo containing `.ai/` |
| `MCP_TARGET_REPO_ROOT` | same as `MCP_REPO_ROOT` | Root of the app to index (can differ for dev) |
| `MCP_DASHBOARD_PORT` | `8722` | Dashboard HTTP port |
| `MCP_ENABLE_DASHBOARD` | `false` | Enable dashboard HTTP server |

---

## 9b. npm Scripts Reference

Add these scripts to your repo's `package.json`:

```json
{
  "scripts": {
    "ai:setup": "node --import tsx .ai/mcp-controller/src/domains/graph-ops/cli.ts seed-facts --sync",
    "ai:check": "node --import tsx .ai/mcp-controller/src/domains/graph-ops/cli.ts check",
    "ai:sync": "node --import tsx .ai/mcp-controller/src/domains/graph-ops/cli.ts sync",
    "ai:seed-facts": "node --import tsx .ai/mcp-controller/src/domains/graph-ops/cli.ts seed-facts --sync",
    "ai:export": "node --import tsx .ai/mcp-controller/src/domains/graph-ops/cli.ts export"
  }
}
```

| Script | Purpose |
|--------|---------|
| `npm run ai:setup` | **Day-0 command:** scan repo AST → generate JSONL → seed Neo4j |
| `npm run ai:check` | Verify Neo4j connectivity |
| `npm run ai:seed-facts` | Re-scan repo + sync (same as setup, run after code changes) |
| `npm run ai:sync` | Reload existing JSONL into Neo4j (no repo scan — for policy-only edits) |
| `npm run ai:export` | Export current graph state to `.ai/graph/out/` |

---

## 10. Folder Layout

```
.ai/
├── auth/                # Jira PAT + secrets (gitignored)
├── config/              # Layered config: base.json → repo.json → env.local.json
├── Docker/              # Docker env example
├── graph/
│   ├── cypher/          # Neo4j constraint scripts
│   ├── seed/            # JSONL seed data (policy, fact, recipe)
│   └── out/             # Export output (gitignored)
├── how-to/              # Guides: memory-system.md, extending-codemods.md
├── memory/
│   ├── overrides/       # Drop JSON files here for human override memories
│   └── records.json     # Runtime memory state
├── mcp-controller/
│   ├── scripts/         # MCP stdio launcher, e2e smoke tests
│   ├── specs/           # Architecture spec
│   ├── src/             # Controller source (TypeScript, runs via tsx)
│   └── tests/           # Unit tests
├── tmp/                 # Scratch files, friction ledger (gitignored)
└── README.md            # ← you are here
```

---

## Troubleshooting

| Problem | Fix |
|---------|-----|
| `ai:check` fails | Neo4j not running, wrong creds, or `piopex` database doesn't exist |
| MCP server won't start in VS Code | Check `node --version` is ≥ 25. Ensure `which node` resolves correctly in terminal |
| Indexer finds no symbols | Check `.ai/config/base.json` `parserTargets` point at your source folders |
| Stale graph after code changes | Run `npm run ai:seed-facts` |
| Stale graph after policy seed edits | Run `npm run ai:sync` |
| `Cannot find module 'tsx'` | Run `npm install -D tsx` in your repo root |
| `Cannot find module 'ts-morph'` | Run `npm install -D ts-morph` in your repo root |
